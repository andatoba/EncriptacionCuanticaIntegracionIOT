# -*- coding: utf-8 -*-
"""ComunicacionAliceBobCS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1t7FCucdIzXK6JLaQJp2nKYPNEVHQ9IZx
"""

!pip install qiskit
!pip install qiskit_machine_learning
!pip install qiskit-aer
!pip install matplotlib
!pip install pylatexenc

!pip install paho-mqtt

!pip install pycryptodome

data = {'t':23.4, 'h':26.2, 'co2':400.2}

from qiskit import QuantumCircuit, transpile, assemble
from qiskit_aer import AerSimulator
import numpy as np
import json

# Función para crear un circuito cuántico para el protocolo BB84
def bb84_protocol(bits, bases):
    circuit = QuantumCircuit(len(bits), len(bits))

    # Preparar los qubits
    for i in range(len(bits)):
        if bits[i] == 1:
            circuit.x(i)  # Aplicar NOT si el bit es 1
        if bases[i] == 1:
            circuit.h(i)  # Aplicar Hadamard si la base es 1

    # Medir los qubits
    circuit.measure(range(len(bits)), range(len(bits)))

    return circuit

# Función para cifrar datos usando XOR
def xor_encrypt(data, key):
    return ''.join(str(int(d) ^ int(k)) for d, k in zip(data, key))

def text_to_binary(text):
    return ''.join(format(ord(char), '08b') for char in text)


def array_to_binary(arr):
    return ''.join(format(num, '08b') for num in arr)

def json_to_binary(arr_json):
    json_string = json.dumps(arr_json)  # Convertir JSON a cadena
    return text_to_binary(json_string)

import time
import base64
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from Crypto.Cipher import Blowfish
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
from collections import Counter


# Función para cifrar usando AES
def aes_encrypt(data, key):
    cipher = AES.new(key, AES.MODE_CBC)  # Usar modo CBC
    ct_bytes = cipher.encrypt(pad(data.encode(), AES.block_size))
    return base64.b64encode(cipher.iv + ct_bytes).decode('utf-8')  # Concatenar IV y texto cifrado

# Función para calcular métricas de un objeto JSON
def calculate_metrics(json_data):
    json_string = json.dumps(json_data)
    size_in_bytes = len(json_string.encode('utf-8'))  # Tamaño en bytes
    num_keys = len(json_data)  # Número de claves
    unique_values = set(json_data.values())  # Valores únicos
    num_unique_values = len(unique_values)  # Contar valores únicos
    avg_value_length = sum(len(str(value)) for value in json_data.values()) / num_keys if num_keys > 0 else 0  # Longitud promedio de los valores

    return {
        "size_in_bytes": size_in_bytes,
        "num_keys": num_keys,
        "num_unique_values": num_unique_values,
        "avg_value_length": avg_value_length
    }

import math

# Función para calcular métricas de los datos encriptados
def calculate_encrypted_metrics(encrypted_data):
    size_in_bits = len(encrypted_data)  # Tamaño en bits
    num_bits = size_in_bits
    num_ones = encrypted_data.count('1')  # Contar bits 1
    num_zeros = encrypted_data.count('0')  # Contar bits 0
    proportion_ones = num_ones / num_bits if num_bits > 0 else 0  # Proporción de bits 1
    proportion_zeros = num_zeros / num_bits if num_bits > 0 else 0  # Proporción de bits 0

    # Calcular entropía
    if num_ones > 0 and num_zeros > 0:
        entropy = - (proportion_ones * math.log2(proportion_ones) + proportion_zeros * math.log2(proportion_zeros))
    else:
        entropy = 0  # Entropía cero si todos los bits son iguales

    return {
        "size_in_bits": size_in_bits,
        "num_bits": num_bits,
        "num_ones": num_ones,
        "num_zeros": num_zeros,
        "proportion_ones": proportion_ones,
        "proportion_zeros": proportion_zeros,
        "entropy": entropy
    }

# Función para enviar datos a un canal MQTT
def send_mqtt_message(broker, port, topic, message):
    client = mqtt.Client()
    client.connect(broker, port)
    client.publish(topic, message)
    client.disconnect()

# Simulación de Alice y Bob

# Alice genera bits aleatorios y bases aleatorias
num_bits = 8
bits_alice = np.random.randint(2, size=num_bits)
bases_alice = np.random.randint(2, size=num_bits)

# Crear el circuito cuántico
circuit = bb84_protocol(bits_alice, bases_alice)
backend = AerSimulator()

# Ejecutar el circuito en el simulador
#simulator = backend.run(circuit, shots=1024)
compiled_circuit = transpile(circuit, backend)
job = backend.run(compiled_circuit, shots=1024)#transpile(circuit, simulator)
#qobj = assemble(compiled_circuit)
result = job.result()

# Obtener los resultados de la medición
counts = result.get_counts()
measured_bits = max(counts, key=counts.get)
#measured_bits = list(counts.keys())[0]  # Tomar el primer resultado
print("Bits medidos:", measured_bits)

# Bob también elige bases aleatorias
bases_bob = np.random.randint(2, size=num_bits)

# Generar clave compartida usando los bits medidos
#key = ''.join(measured_bits[i] for i in range(num_bits) if bases[i] == 0)  # Suponiendo que ambas bases coinciden
shared_key = ''.join(measured_bits[i] for i in range(num_bits) if bases_alice[i] == bases_bob[i])

print("Bits de Alice:", bits_alice)
print("Bases de Alice:", bases_alice)
print("Bases de Bob:", bases_bob)
print("Bits medidos por Bob:", measured_bits)
print("Clave compartida:", shared_key)

# Datos a cifrar
data_to_send = json_to_binary(data)  # Ejemplo de datos
# Asegurarse de que la longitud de la clave sea igual a la de los datos
if len(shared_key) < len(data_to_send):
    shared_key = shared_key * (len(data_to_send) // len(shared_key)) + shared_key[:len(data_to_send) % len(shared_key)]  # Repetir y ajustar la clave
print("Clave ajustada:", shared_key)

start_time = time.time()
encrypted_xor = xor_encrypt(data_to_send, shared_key)
xor_time = time.time() - start_time
print("Datos cifrados XOR:", encrypted_xor)

 # Cifrar usando AES
key_aes = int(shared_key, 2).to_bytes(16, 'big')  # Convertir clave a 16 bytes para AES-128
cipher = AES.new(key_aes, AES.MODE_CBC)
iv = cipher.iv
start_time = time.time()
encrypted_aes = cipher.encrypt(pad(data_to_send.encode(), AES.block_size))
aes_time = time.time() - start_time
print("Datos cifrados (AES):", encrypted_aes.hex())

# ---- DESCIFRADO ----
# Descifrado XOR
decrypted_data = xor_encrypt(encrypted_xor, shared_key)
print("Datos desencriptados (XOR):", decrypted_data)

# Descifrado AES
cipher = AES.new(key_aes, AES.MODE_CBC, iv)
decrypted_aes = unpad(cipher.decrypt(encrypted_aes), AES.block_size).decode()
print("Datos desencriptados (AES):", decrypted_aes)

print("Datos cifrados con XOR:", encrypted_xor)
print("Tiempo de cifrado XOR:", xor_time)

# Cifrar los datos usando AES
print("Datos cifrados con AES:", encrypted_aes)
print("Tiempo de cifrado AES:", aes_time)

import paho.mqtt.client as mqtt

# Enviar datos cifrados a un canal MQTT
broker = "mqtt-dashboard.com"  # Cambia esto por tu broker
port = 8884  # Puerto por defecto para MQTT
topic = "qsensor"  # Cambia esto por tu tema deseado

send_mqtt_message(broker, port, topic, encrypted_data)

print(circuit.draw(output='text'))

from qiskit.visualization import plot_bloch_multivector
from qiskit_aer import StatevectorSimulator

simulator = StatevectorSimulator()
result = simulator.run(circuit).result()
statevector = result.get_statevector()

# Visualize the statevector on the Bloch sphere
plot_bloch_multivector(statevector)

# Convertir los datos desencriptados de binario a texto
decrypted_string = ''.join(chr(int(decrypted_data[i:i+8], 2)) for i in range(0, len(decrypted_data), 8))
print("Datos desencriptados como JSON:", decrypted_string)

# Calcular métricas
metrics = calculate_metrics(data)
print("Métricas de los datos enviados:", metrics)

metrics = calculate_encrypted_metrics(encrypted_xor)
print("Métricas de los datos encriptados:", metrics)

import numpy as np

# Función para simular el protocolo BB84
def bb84_protocol(num_bits):
    # Generar bits y bases aleatorias para Alice
    bits_alice = np.random.randint(2, size=num_bits)
    bases_alice = np.random.randint(2, size=num_bits)

    # Simular la medición de Bob
    bases_bob = np.random.randint(2, size=num_bits)
    measured_bits = []

    for i in range(num_bits):
        # Simular la medición de Bob
        if bases_bob[i] == bases_alice[i]:
            # Si las bases coinciden, Bob mide el bit de Alice
            measured_bits.append(bits_alice[i])
        else:
            # Si las bases no coinciden, Bob obtiene un resultado aleatorio
            measured_bits.append(np.random.randint(2))

    # Generar la clave compartida
    shared_key = []
    for i in range(num_bits):
        if bases_alice[i] == bases_bob[i]:
            shared_key.append(measured_bits[i])

    return bits_alice, bases_alice, bases_bob, measured_bits, shared_key

# Parámetros
num_bits = 8

# Ejecutar el protocolo
bits_alice, bases_alice, bases_bob, measured_bits, shared_key = bb84_protocol(num_bits)

# Mostrar resultados
print("Bits de Alice:", bits_alice)
print("Bases de Alice:", bases_alice)
print("Bases de Bob:", bases_bob)
print("Bits medidos por Bob:", measured_bits)
print("Clave compartida:", shared_key)