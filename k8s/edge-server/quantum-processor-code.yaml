apiVersion: v1
kind: ConfigMap
metadata:
  name: quantum-processor-code
  namespace: quantum-access-control
data:
  quantum_processor.py: |
    #!/usr/bin/env python3
    
    import os
    import json
    import time
    import paho.mqtt.client as mqtt
    import requests
    import logging
    import numpy as np
    from datetime import datetime
    
    # Set up logging
    logging.basicConfig(level=logging.INFO, 
                        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    logger = logging.getLogger('quantum-processor')
    
    # MQTT Configuration
    mqtt_broker = os.environ.get('MQTT_BROKER', 'localhost')
    mqtt_port = int(os.environ.get('MQTT_PORT', 1883))
    mqtt_topic = os.environ.get('MQTT_TOPIC', 'qsensor/rfid')
    
    # Orion Context Broker Configuration
    orion_host = os.environ.get('ORION_HOST', 'localhost')
    orion_port = os.environ.get('ORION_PORT', 1026)
    orion_url = f"http://{orion_host}:{orion_port}/v2/entities"
    
    # Authorized UUIDs
    AUTHORIZED_UIDS = ["0A1B2C3D", "4E5F6G7H", "8I9J0K1L"]

        # Add more UUIDs here
    ]
    
    # BB84 protocol functions (simplified for demonstration)
    def xor_decrypt(encrypted_data, key):
        # Adjust key length
        full_key = key * (len(encrypted_data) // len(key)) + key[:len(encrypted_data) % len(key)]
        
        # XOR decryption
        decrypted_binary = ''.join(str(int(e) ^ int(k)) for e, k in zip(encrypted_data, full_key))
        
        # Convert binary to string
        chunks = [decrypted_binary[i:i+8] for i in range(0, len(decrypted_binary), 8)]
        return ''.join(chr(int(chunk, 2)) for chunk in chunks)
    
    def bb84_simulate(alice_bits, alice_bases, bob_bases):
        # Simulate BB84 protocol
        measured_bits = []
        for i in range(len(alice_bits)):
            if bob_bases[i] == alice_bases[i]:
                measured_bits.append(alice_bits[i])
            else:
                measured_bits.append(np.random.randint(0, 2))
        
        # Generate shared key from matching bases
        shared_key = ""
        for i in range(len(alice_bits)):
            if alice_bases[i] == bob_bases[i]:
                shared_key += str(alice_bits[i])
                
        return measured_bits, shared_key
    
    def on_connect(client, userdata, flags, rc):
        if rc == 0:
            logger.info(f"Connected to MQTT broker at {mqtt_broker}")
            client.subscribe(mqtt_topic)
            logger.info(f"Subscribed to topic: {mqtt_topic}")
        else:
            logger.error(f"Failed to connect to MQTT broker with result code {rc}")
    
    def on_message(client, userdata, msg):
        try:
            logger.info(f"Received message on {msg.topic}")
            
            # Parse the message
            payload = json.loads(msg.payload.decode('utf-8'))
            encrypted_data = payload.get('data')
            device_id = payload.get('device_id')
            
            # Decrypt the data (simulated quantum key)
            shared_key = '01101101'  # In a real system, this would come from BB84
            decrypted_json = xor_decrypt(encrypted_data, shared_key)
            
            # Parse the decrypted data
            data = json.loads(decrypted_json)
            
            # Get BB84 data
            alice_bits = data.get('alice_bits', [])
            alice_bases = data.get('alice_bases', [])
            card_id = data.get('card_id', 'unknown')
            timestamp = data.get('timestamp', datetime.now().isoformat())
            
            # Generate Bob's random bases (would be actual measurements in a quantum system)
            bob_bases = np.random.randint(0, 2, size=len(alice_bits)).tolist()
            
            # Simulate BB84 protocol
            measured_bits, shared_key = bb84_simulate(alice_bits, alice_bases, bob_bases)
            
            logger.info(f"Processed card: {card_id}")
            logger.info(f"Generated shared key: {shared_key}")
            
            # Create an entity to send to Orion Context Broker
            entity = {
                "id": f"RFIDCard:{card_id}",
                "type": "RFIDCard",
                "cardId": {
                    "type": "Text",
                    "value": card_id
                },
                "timestamp": {
                    "type": "DateTime",
                    "value": timestamp
                },
                "deviceId": {
                    "type": "Text",
                    "value": device_id
                },
                "accessGranted": {
                    "type": "Boolean",
                    "value": card_id in AUTHORIZED_UIDS and len(shared_key) >= 4  # Verificaci√≥n de UID y calidad de clave
                },
                "keyQuality": {
                    "type": "Number",
                    "value": len(shared_key) / len(alice_bits) if alice_bits else 0
                }
            }
            
            # Send to Orion Context Broker
            headers = {'Content-Type': 'application/json'}
            try:
                response = requests.post(orion_url, json=entity, headers=headers)
                if response.status_code == 201 or response.status_code == 204:
                    logger.info(f"Entity successfully created/updated in Orion: {card_id}")
                else:
                    logger.error(f"Failed to update Orion: {response.status_code} - {response.text}")
            except requests.exceptions.RequestException as e:
                logger.error(f"Error sending data to Orion: {e}")
            
        except json.JSONDecodeError as e:
            logger.error(f"Invalid JSON in message: {e}")
        except Exception as e:
            logger.error(f"Error processing message: {e}")
    
    def main():
        # Set up MQTT client
        client = mqtt.Client()
        client.on_connect = on_connect
        client.on_message = on_message
        
        # Connect to the MQTT broker
        try:
            logger.info(f"Connecting to MQTT broker at {mqtt_broker}:{mqtt_port}")
            client.connect(mqtt_broker, mqtt_port, 60)
            
            # Start the MQTT loop
            client.loop_forever()
        except Exception as e:
            logger.error(f"Failed to connect to MQTT broker: {e}")
            time.sleep(5)  # Wait before retrying
    
    if __name__ == "__main__":
        while True:
            try:
                main()
            except Exception as e:
                logger.error(f"Main loop error: {e}")
                time.sleep(5)  # Wait before restarting
